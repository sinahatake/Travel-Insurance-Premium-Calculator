### **1. Создание и запуск задач**

* Создаётся `ExecutorService` с фиксированным количеством потоков (`Executors.newFixedThreadPool(threadCount)`).
* Каждая задача (`Runnable` или `Callable`) отправляется в пул через `submit()`.
* `Runnable` — если задача ничего не возвращает.
* `Callable<T>` — если задача возвращает результат (`Future<T>`).

---

### **2. Два способа ожидания завершения задач**

#### **Способ 1: Через `Future.get()`**

* При отправке задачи через `submit()` получаем объект `Future`.
* Метод `future.get()` **блокирует текущий поток** до завершения конкретной задачи.
* Пример:

```java
for (Future<?> future : futures) {
    try {
        future.get(); // ждём окончания задачи
    } catch (InterruptedException | ExecutionException e) {
        log.error("Ошибка при выполнении задачи", e);
    }
}
```

* Плюс: можно получать результат задачи.
* Минус: текущий поток полностью блокируется.

#### **Способ 2: Через `shutdown()` + `awaitTermination()`**

* Вызываем `executorService.shutdown()`, чтобы пул больше не принимал новые задачи.
* Метод `awaitTermination(timeout, unit)` ждёт максимум указанное время или до завершения всех задач.
* Пример:

```java
executorService.shutdown();
executorService.awaitTermination(5, TimeUnit.MINUTES);
```

* Плюс: просто дождаться завершения всех задач без работы с `Future`.
* Минус: нельзя получить результаты отдельных задач напрямую.

---

### **Итог**

* **Если нужна блокировка и результат каждой задачи** → используем `Future.get()`.
* **Если просто нужно дождаться окончания всех задач** → используем `shutdown()` + `awaitTermination()`.
* Часто используют **комбинацию**: собирают `Future` для ожидания и `shutdown()` для корректного завершения пула.
